#!/usr/bin/env python
# encoding: utf-8
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# The code is based on an original idea of Reinout van Weeren

import sys
import os
import logging
import pickle
import factor
import factor.directions
import factor.parset
import factor.cluster
from factor.operations.field_ops import *
from factor.operations.facet_ops import *


if __name__=='__main__':
    import optparse
    opt = optparse.OptionParser(usage='%prog [-v|-q] parset [default: factor.parset] \n',
            version='%%prog %s' % (factor._version.__version__))
    opt.add_option('-q', help='Quiet', action='store_true', default=False)
    opt.add_option('-v', help='Verbose', action='store_true', default=False)
    (options, args) = opt.parse_args()

    if len(args) not in [0, 1]:
        opt.print_help()
        sys.exit()

    # Prepare logging
    if options.q:
        factor._logging.set_level('warning')
    if options.v:
        factor._logging.set_level('debug')

    # Prepare parset
    try:
        parset_file = args[0]
    except:
        parset_file = 'factor.parset'
    parset = factor.parset.parset_read(parset_file)

    # Prepare vis data
    bands = []
    from factor.lib.band import Band
    for ms in parset['mss']:
        band = Band(ms)
        band.dirindparmdb = os.path.join(band.file, parset['parmdb_name'])
        if not os.path.exists(band.dirindparmdb):
            logging.critical('Direction-independent instument parmdb not found '
                'for band {0}'.format(band.file))
            sys.exit(1)
        band.skymodel_dirindep = None
        msbase = os.path.basename(ms)
        if msbase in parset['ms_specific']:
            if 'init_skymodel' in parset['ms_specific'][msbase]:
                band.skymodel_dirindep = parset['ms_specific'][msbase]['init_skymodel']
        bands.append(band)

    # Check directions. First check for user-supplied file, then for Factor-generated
    # file from a previous run, then for parameters needed to generate it internally
    if 'directions_file' in parset:
        directions = factor.directions.directions_read(parset['directions_file'])
    elif os.path.exists(os.path.join(parset['dir_working'], 'factor_directions.txt')):
        directions = factor.directions.directions_read(os.path.join(parset['dir_working'],
            'factor_directions.txt'))
    else:
        if 'directions_flux_min_jy' not in parset or \
            'directions_size_max_arcmin' not in parset or \
            'directions_separation_max_arcmin' not in parset:
                logging.critical('If no directions file is specified, you must '
                    'give values for directions_flux_min_Jy, '
                    'directions_size_max_arcmin, and directions_separation_max_arcmin')
                sys.exit(1)
        else:
            directions = None

    # Get nodes from cluster description
    if parset['clusterdesc'].lower() == 'pbs':
        parset['clusterdesc'] = factor.cluster.make_pbs_clusterdesc(
            parset['node_local_disk'])
    if not 'node_list' in parset:
        parset['node_list'] = factor.cluster.get_compute_nodes(parset['clusterdesc'])

    # Run initial sky model generation and create empty datasets. First check that
    # this operation is needed (only needed if band lacks an initial skymodel or
    # the SUBTRACTED_DATA_ALL column).
    bands_init_subtract = []
    for band in bands:
        if band.skymodel_dirindep is None or not band.has_sub_data:
            bands_init_subtract.append(band)
    if len(bands_init_subtract) > 0:
        op = InitSubtract(parset, bands_init_subtract)
        op.run()
    else:
        logging.info("Sky models found for all MS files. Skipping initial subtraction "
            "operation")

    # Prepare directions
    if directions is None:
        # Make directions from dir-indep sky models using flux and size parameters
        logging.info("No directions file given. Selecting directions internally...")
        parset['directions_file'] = factor.directions.make_directions_file_from_skymodel(bands,
        	parset['directions_flux_min_jy'],
        	parset['directions_size_max_arcmin'],
        	parset['directions_separation_max_arcmin'],
        	directions_max_num=parset['directions_max_num'],
        	interactive=parset['interactive'])
        directions = factor.directions.directions_read( parset['directions_file'] )
    dir_reg = [d for d in directions if d.reg != '']
    for i, direction in enumerate(dir_reg):
        direction.vertices, direction.width = factor.directions.region_read(direction.reg)
    dir_no_reg = [d for d in directions if d.reg == '']
    polys, widths = factor.directions.thiessen(dir_no_reg)
    for i, direction in enumerate(dir_no_reg):
        direction.vertices = polys[i]
        direction.width = widths[i]
        reg_file = os.path.join(parset['dir_working'], 'regions', direction.name+'.reg')
        factor.directions.make_region_file(direction.vertices, reg_file)
        direction.reg = reg_file
    ds9_reg_file = os.path.join(parset['dir_working'], 'factor_directions_ds9.reg')
    factor.directions.make_ds9_region_file(directions, ds9_reg_file)

    # Select subset of directions to process
    if 'ndir' in parset:
        if parset['ndir'] > 0 and parset['ndir'] <= len(directions):
            directions = directions[:parset['ndir']]

    # Group directions into groups that are processed in parallel
    if parset['ndir_parallel'] > 1:
        one_at_a_time = False
    else:
        one_at_a_time = True
    direction_groups = factor.directions.group_directions(directions, one_at_a_time)

    # Iterate over direction groups
    for direction_group in direction_groups:
        logging.info('Processing {0} direction(s) in parallel'.format(
            len(direction_group)))

        # Add calibrator(s) to empty datasets. These operations
        # must be done in series
        ops = [FacetAddCal(parset, bands, d) for d in direction_group]
        for op in ops:
            op.run()

        # Setup up facet(s) for selfcal of calibrator
        op = FacetSetup(parset, bands, direction_group)
        op.run()

        # Do selfcal on calibrator only
        op = FacetSelfcal(parset, bands, direction_group)
        op.run()

        # Add all sources in the facet(s) to empty datasets. These operations
        # must be done in series
        ops = [FacetAddAll(parset, bands, d) for d in direction_group]
        for op in ops:
            op.run()

        # Make image of all sources in the facet(s) and get final model(s)
        op = FacetImage(parset, bands, direction_group)
        op.run()

        # Subtract final model(s) from empty datasets. These operations
        # must be done in series
        ops = [FacetSubAll(parset, bands, d) for d in direction_group]
        for op in ops:
            op.run()

    # Make final facet images (from final empty datasets) if desired
    dirs_to_image = [d for d in directions if d.make_final_image]
    if len(dirs_to_image) > 0:
        ops = [FacetAddAllFinal(parset, bands, d) for d in dirs_to_image]
        for op in ops:
            op.run()
        op = FacetImageFinal(parset, bands, dirs_to_image)
        op.run()

    # Save final band and direction objects to disk
    pickle.dump(bands, open(os.path.join(parset['dir_working'],
    	"bands.sav"), "wb" ))
    pickle.dump(directions,	open(os.path.join(parset['dir_working'],
        "directions.sav"), "wb" ))

    # Mosaic the final facet images together
    if parset['make_mosaic']:
        op = MakeMosaic(parset, directions)
        op.run()

    logging.info("Factor has finished :)")


